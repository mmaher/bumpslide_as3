/**
 * This code is part of the Bumpslide Library maintained by David Knape
 * Fork me at http://github.com/tkdave/bumpslide_as3
 * 
 * Copyright (c) 2010 by Bumpslide, Inc. 
 * http://www.bumpslide.com/
 *
 * This code is released under the open-source MIT license.
 * See LICENSE.txt for full license terms.
 * More info at http://www.opensource.org/licenses/mit-license.php
 */

package com.bumpslide.ui {	import com.bumpslide.data.type.Padding;	import com.bumpslide.events.UIEvent;	import com.bumpslide.ui.skin.defaults.Style;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.geom.Rectangle;	/**	 * Simple Container with Background box and padding.	 * 	 * This is a core base class for the scroll panels and grids	 * 	 * This component can be instantiated via code, or it can be created 	 * inside a FLA.  Missing pieces will be dynamically added to the 	 * display list. Background is no longer transparent by default.  We still 	 * need it for absorbing certain mouse events in various child components.	 *   	 * @author David Knape	 */	public class Panel extends Component 	{		// children		public var background:DisplayObject;		public var viewrect:Sprite; // avatar on stage to determine content padding		protected var _content:DisplayObject;		protected var _holder:Sprite;		// content and scrollbar padding in relationship to background		protected var _padding:Padding; 		protected var _autoSizeHeight:Boolean = false;		protected var _constructorArgs:Array;				private var _backgroundVisible:Boolean = true;				function Panel( content:DisplayObject = null, padding:*=  null, background_color:uint = NaN, background_alpha:Number = NaN):void 		{			_constructorArgs = arguments;			super();		}				override protected function postConstruct():void 		{
			super.postConstruct();						// apply constructor arguments			if(_constructorArgs!=null) {				if(content==null) content = _constructorArgs[0];				if(_constructorArgs[1]!=null) padding = _constructorArgs[1];				if(backgroundBox != null && !isNaN( _constructorArgs[2])) backgroundBox.backgroundColor = _constructorArgs[2];				if(!isNaN( _constructorArgs[3])) background.alpha = _constructorArgs[3];			}
		}
				override protected function initSize():void 		{
			super.initSize();						if(explicitWidth == 0 && explicitHeight == 0) {				width = 256;				height = 256;			}
		}
				/**		 * init		 */		override protected function addChildren():void 		{						//debugEnabled = true;									delayUpdate = false;			initPadding();			initBackground();			initContent();						}				override public function destroy():void 		{			destroyChild(content);			super.destroy();		}				/**		 * Uses viewrect on stage to determine appropriate padding		 * By default, the _defaultPadding value is used		 */		protected function initPadding():void 		{			// define viewrect					if(viewrect == null) {				if(_padding == null) _padding = new Padding(Style.PANEL_PADDING);			} else {				var b:Rectangle = viewrect.getBounds(this);								_padding = new Padding(b.y, width - b.right, height - b.bottom, b.x);				removeChild(viewrect);			}		}				/**		 * Create background if there wasn't one on stage		 */		protected function initBackground():void 		{			if(background == null) {				background = new Box(Style.PANEL_BACKGROUND_COLOR, width, height);				addChild(background);			}			}				/**		 * Initializes content holder and scrollrect		 */		protected function initContent():void 		{			// create content holder						_holder = new Sprite();			addChild(_holder);		}				override public function layoutChildren():void 		{
			super.layoutChildren();			drawBackground();			positionContent();
		}
				/**		 * Draws the background		 */		protected function drawBackground():void 		{			background.height = height;			background.width = width;			background.visible = backgroundVisible;		}				/**		 * Positions holder and sizes scroll rect for no scrollbar 		 */		override protected function draw():void 		{												setContentSize(contentWidth, contentHeight);			if(autoSizeHeight && content != null && content is Component) {				(content as Component).updateNow();			}					}				protected function positionContent():void 		{			_holder.x = _padding.left;			_holder.y = _padding.top;		}				protected function setContentSize(w:Number, h:Number):void 		{			scrollRectSet('width', w);						if(autoSizeHeight) {				if(content) content.width = contentWidth;			} else {								scrollRectSet('height', h);						if(content is IResizable) {					(content as IResizable).setSize(w, h);				}			}		}				protected function scrollRectSet( prop:String, value:Number ):void 		{			if(_holder == null) return;			if(_holder.scrollRect == null) _holder.scrollRect = new Rectangle();			var rect:Rectangle = _holder.scrollRect;			rect[prop] = Math.round(value);			_holder.scrollRect = rect;		}				//-------------------		// GETTERS/SETTERS		//-------------------				/**		 * The content being scrolled		 */			public function set content( c:DisplayObject ):void {				// if we had old content, remove it			if(_content != null && _holder.contains(_content) ) {				_holder.removeChild(_content);			}			// add to stage inside holder						if(c != null) _holder.addChild(c);										_content = c;			invalidate();		}				public function get content():DisplayObject {			return _content;		}				public function get contentWidth():Number {			return width - _padding.width;		}				public function get contentHeight():Number {			return height - _padding.height;		}				public function set padding( p:* ):void {			_padding = Padding.create( p );			invalidate();		}						public function get padding():Padding {			return _padding;		}				/**		 * If background was not explicitly set or placed on the stage, this is the default background		 */		public function get backgroundBox():Box {			if(background is Box) {				return background as Box;			} else {				return null;			}		}				public function get autoSizeHeight():Boolean {			return _autoSizeHeight;		}				public function set autoSizeHeight(autoSize:Boolean):void {			_autoSizeHeight = autoSize;			invalidate();		}				override public function get height():Number {			// get display object height.  Calls actualHeight getter from component class if found			// this is overriden by TextBox to return the 			var contentheight:Number = content ? (content is Component ? (content as Component).actualHeight : content.height) : 0;			return (autoSizeHeight) ? contentheight + padding.height : super.height;		}						public function get backgroundVisible():Boolean {			return _backgroundVisible;		}						public function set backgroundVisible(backgroundVisible:Boolean):void {			_backgroundVisible = backgroundVisible;			invalidate();		}	}}